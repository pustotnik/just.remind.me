#!/usr/bin/env python
# coding=utf8
#

import sys, os
import shutil

_joinpath  = os.path.join
_abspath   = os.path.abspath

from waflib import Configure, Build, Options, Context, Logs

# Avoid writing .pyc files
sys.dont_write_bytecode = True
import buildconf
import assist
sys.dont_write_bytecode = False

#WAF_DIR = Context.waf_dir

# FIXME: move to buildconf
engineLibName = 'jrm-engine'
runnerName    = 'runner'

BUILD_TYPES = ('debug', 'release')
COMPILERS   = ('g++', 'clang++')
COMPILER = 'clang++'
#COMPILER = 'g++'
#COMPILER = 'compiler_cxx'

# Execute the configuration automatically
Configure.autoconfig = buildconf.AUTO_CONFIGURE if hasattr(buildconf, 'AUTO_CONFIGURE') else False

"""
TODO: see waflib/extras/pyqt5.py
"""

# WAF detected any our function as command and you can find it with --help.
# So I decided to make such a 'namespace'
class tools:

    @staticmethod
    def makeTargetPath(ctx, targetName):
        #return _joinpath(targetName)
        return _joinpath(ctx.out_dir, ctx.variant, targetName)

"""
    WAF routines
"""

# these variables are mandatory ('/' are converted automatically)
top = assist.BUILDROOT
out = _joinpath(assist.BUILDROOT, 'out')

APPNAME = buildconf.PROJECTNAME
VERSION = buildconf.VERSION

def options(opt):
    opt.add_option('-b', '--buildtype', action = 'store', choices = BUILD_TYPES,
                    default = buildconf.DEFAULT_BUILD_TYPE,
                    help = 'set the build type')
    #opt.load('compiler_cxx')
    #opt.load(COMPILER)

def init(ctx):
    from copy import deepcopy
    assist.wafcommands = deepcopy(Options.commands)

    for c in (Build.BuildContext, Build.CleanContext, Build.InstallContext, Build.UninstallContext):
        #name = c.__name__.replace('Context','').lower()
        class CtxClass(c):
            #cmd     = name + '-' + bt
            variant = Options.options.buildtype

def configure(ctx):

    # See details here: https://gitlab.com/ita1024/waf/issues/1563
    #ctx.env.NO_LOCK_IN_RUN = True

    """
    TODO: think about:
    With NO_LOCK_IN_TOP = True this doesn't work:
    # ./waf/make.py configure
    # ./waf/make.py build
    # The project was not configured: run "waf configure" first!
    BUT this works:
    ./waf/make.py configure build
    So I can use NO_LOCK_IN_TOP = True if I use 'configure' every time before 'build'
    """
    #ctx.env.NO_LOCK_IN_TOP = True

    """
    for bt in BUILD_TYPES:
        for compiler in COMPILES:
            #variant = bt + '-' + compiler
            variant = bt
            ctx.setenv(variant)
            if bt == 'debug':
                ctx.env.CXXFLAGS = ['-g']
            else:
                ctx.env.CXXFLAGS = ['-O2']
    #"""

    #ctx.load('compiler_cxx')
    #ctx.load(COMPILER)

    defaultEnv = ctx.env.derive()
    ctx.setenv('debug', env = defaultEnv)
    ctx.load('g++')
    ctx.setenv('release', env = defaultEnv)
    ctx.load('clang++')

    #ctx.check(header_name='stdio.h', features='cxx cxxprogram', mandatory=False)
    ctx.check(header_name='cstdio', features='cxx cxxprogram', mandatory=True)

def build(ctx):

    if not ctx.variant:
        ctx.fatal('No variant!')

    #print(ctx.env)
    #print(ctx.all_envs)
    #print(ctx.path.abspath())
    #print(ctx.root.abspath())

    cxxflags = '-pthread -std=c++17 -Wall -Wextra -Woverloaded-virtual' + \
                ' -Wunreachable-code -Wvla -O0 -g -fno-omit-frame-pointer'

    #ctx.root.find_dir
    #ctx(source = tools.collectFilesWithWildcard(_joinpath(SRCROOT, 'engine'), '*.cpp'),
    #ctx(source = '../../just.remind.me/src/engine/application.cpp',
    #ctx(source = ctx.path.parent.ant_glob('src/engine/**/*.cpp'),
    #print(_joinpath(SRCROOT, 'engine') + '/**/*.cpp')
    #ctx(source = ctx.root.ant_glob((_joinpath(SRCSYMLINK, 'engine') + '/**/*.cpp')[1:]),
    ctx(source = ctx.path.ant_glob('%s/engine/**/*.cpp' % assist.SRCSYMLINKNAME),
    #ctx.shlib(source = ctx.path.parent.ant_glob('src/engine/**/*.cpp'),
                target = tools.makeTargetPath(ctx, engineLibName),
                name = engineLibName,
                features='cxx cxxshlib',
                #includes = SRCROOT,
                includes = assist.SRCSYMLINK,
                #cxxflags  = '-O3',
                cxxflags  = cxxflags,
                lib = ['m', 'rt', 'pthread'],
                vnum = VERSION)

    #ctx.variant = 'release'

    #ctx(source = ctx.path.parent.ant_glob('src/runner/**/*.cpp'),
    ctx(source = ctx.path.ant_glob('%s/runner/**/*.cpp' % assist.SRCSYMLINKNAME),
    #ctx.program(source = ctx.path.parent.ant_glob('src/runner/**/*.cpp'),
                features='cxx cxxprogram',
                target = tools.makeTargetPath(ctx, runnerName),
                use = engineLibName,
                #lib = ['m', 'rt', 'pthread'],

                #defines      = ['LINUX=1', 'BIDULE'],
                #lib          = ['m'],
                #libpath      = ['/usr/lib'],
                #rpath        = ['/opt/kde/lib'],
                #idx          = 123, # Setting the counter for the object file extension is sometimes necessary to avoid object file name collisions
                #install_path = '${SOME_PATH}/bin',

                cxxflags  = cxxflags,
                includes = assist.SRCROOT)

#!/usr/bin/env python
# coding=utf8
#

import sys, os
import shutil

joinpath  = os.path.join
abspath   = os.path.abspath

from waflib import Configure, Build, Options, Logs

# Avoid writing .pyc files
sys.dont_write_bytecode = True
import buildconf
import utils

PROJECTNAME  = buildconf.PROJECTNAME
BUILDROOT    = utils.unfoldPath(buildconf.BUILDROOT)
BUILDSYMLINK = utils.unfoldPath(buildconf.BUILDSYMLINK)
PROJECTROOT  = utils.unfoldPath(buildconf.PROJECTROOT)

# these variables are mandatory ('/' are converted automatically)
top = PROJECTROOT
out = BUILDSYMLINK

APPNAME = buildconf.PROJECTNAME
VERSION = buildconf.VERSION

# FIXME: move to buildconf
engineLibName = 'jrm-engine'
runnerName    = 'runner'

BUILD_TYPES = ('debug', 'release')
COMPILERS   = ('g++', 'clang++')
COMPILER = 'clang++'
#COMPILER = 'g++'
#COMPILER = 'compiler_cxx'

# Execute the configuration automatically
Configure.autoconfig = buildconf.AUTO_CONFIGURE if hasattr(buildconf, 'AUTO_CONFIGURE') else False

"""
TODO: see waflib/extras/pyqt5.py
"""

def prepareBuildDir():

    if len(Options.commands) == 1 and Options.commands[0] == 'distclean':
        return

    if not os.path.exists(BUILDROOT):
        os.makedirs(BUILDROOT)
    if BUILDSYMLINK and not os.path.exists(BUILDSYMLINK):
        os.symlink(BUILDROOT, BUILDSYMLINK)

def makeTargetPath(ctx, targetName):
    #return joinpath(targetName)
    return joinpath(ctx.out_dir, ctx.variant, targetName)

"""
    WAF routines
"""

def options(opt):
    opt.add_option('-b', '--buildtype', action = 'store', choices = BUILD_TYPES,
                    default = buildconf.DEFAULT_BUILD_TYPE,
                    help = 'set the build type')
    #opt.load('compiler_cxx')
    #opt.load(COMPILER)

def init(ctx):
    prepareBuildDir()

    for c in (Build.BuildContext, Build.CleanContext, Build.InstallContext, Build.UninstallContext):
        #name = c.__name__.replace('Context','').lower()
        class CtxClass(c):
            #cmd     = name + '-' + bt
            variant = Options.options.buildtype

def configure(ctx):

    # See details here: https://gitlab.com/ita1024/waf/issues/1563
    ctx.env.NO_LOCK_IN_RUN = True

    """
    TODO: think about:
    With NO_LOCK_IN_TOP = True this doesn't work:
    # ./waf/make.py configure
    # ./waf/make.py build
    # The project was not configured: run "waf configure" first!
    BUT this works:
    ./waf/make.py configure build
    So I can use NO_LOCK_IN_TOP = True if I use 'configure' every time before 'build'
    """
    #ctx.env.NO_LOCK_IN_TOP = True

    """
    for bt in BUILD_TYPES:
        for compiler in COMPILES:
            #variant = bt + '-' + compiler
            variant = bt
            ctx.setenv(variant)
            if bt == 'debug':
                ctx.env.CXXFLAGS = ['-g']
            else:
                ctx.env.CXXFLAGS = ['-O2']
    #"""

    #ctx.load('compiler_cxx')
    #ctx.load(COMPILER)

    defaultEnv = ctx.env.derive()
    ctx.setenv('debug', env = defaultEnv)
    ctx.load('g++')
    ctx.setenv('release', env = defaultEnv)
    ctx.load('clang++')

    #ctx.check(header_name='stdio.h', features='cxx cxxprogram', mandatory=False)
    ctx.check(header_name='cstdio', features='cxx cxxprogram', mandatory=True)

def build(ctx):

    if not ctx.variant:
        ctx.fatal('No variant!')

    #print(ctx.env)
    #print(ctx.all_envs)

    cxxflags = '-pthread -std=c++17 -Wall -Wextra -Woverloaded-virtual' + \
                ' -Wunreachable-code -Wvla -O0 -g -fno-omit-frame-pointer'

    ctx.shlib(source = ctx.path.parent.ant_glob('src/engine/**/*.cpp'),
                target = makeTargetPath(ctx, engineLibName),
                name = engineLibName,
                features='cxx cxxshlib',
                includes = buildconf.SRCROOT,
                #cxxflags  = '-O3',
                cxxflags  = cxxflags,
                lib = ['m', 'rt', 'pthread'],
                vnum = VERSION)

    #ctx.variant = 'release'

    ctx.program(source = ctx.path.parent.ant_glob('src/runner/**/*.cpp'),
                features='cxx cxxprogram',
                target = makeTargetPath(ctx, runnerName),
                use = engineLibName,
                #lib = ['m', 'rt', 'pthread'],

                #defines      = ['LINUX=1', 'BIDULE'],
                #lib          = ['m'],
                #libpath      = ['/usr/lib'],
                #rpath        = ['/opt/kde/lib'],
                #idx          = 123, # Setting the counter for the object file extension is sometimes necessary to avoid object file name collisions
                #install_path = '${SOME_PATH}/bin',

                cxxflags  = cxxflags,
                includes = buildconf.SRCROOT)

def distclean(ctx):

    # Default implemention doesn't work if 'ctx.env.NO_LOCK_IN_TOP == True' because of bug

    if BUILDSYMLINK and os.path.isdir(BUILDSYMLINK) and os.path.exists(BUILDSYMLINK):
        Logs.info("Removing directory '%s'" % BUILDSYMLINK)
        shutil.rmtree(BUILDSYMLINK, ignore_errors = True)

    if BUILDSYMLINK and os.path.islink(BUILDSYMLINK) and os.path.lexists(BUILDSYMLINK):
        Logs.info("Removing symlink '%s'" % BUILDSYMLINK)
        os.remove(BUILDSYMLINK)

    if os.path.exists(BUILDROOT):
        Logs.info("Removing directory '%s'" % BUILDROOT)
        shutil.rmtree(BUILDROOT, ignore_errors = True)

    lockfile = os.path.join(PROJECTROOT, Options.lockfile)
    if os.path.exists(lockfile):
        Logs.info("Removing lockfile '%s'" % lockfile)
        os.remove(lockfile)

    lockfile = os.path.join(PROJECTROOT, 'waf', Options.lockfile)
    if os.path.exists(lockfile):
        Logs.info("Removing lockfile '%s'" % lockfile)
        os.remove(lockfile)

    if len(Options.commands) > 0:
        prepareBuildDir()
